!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("Hashids",[],e):"object"==typeof exports?exports.Hashids=e():t.Hashids=e()}(self,(function(){return(()=>{"use strict";var t={d:(e,s)=>{for(var i in s)t.o(s,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>l});const s=t=>"bigint"==typeof t||!Number.isNaN(Number(t))&&Math.floor(Number(t))===t,i=t=>"bigint"==typeof t||t>=0&&Number.isSafeInteger(t);function n(t,e){if(0===e.length)return t;let s;const i=[...t];for(let t=i.length-1,n=0,r=0;t>0;t--,n++){n%=e.length,r+=s=e[n].codePointAt(0);const h=(s+n+r)%t,o=i[t],a=i[h];i[h]=o,i[t]=a}return i}const r=(t,e)=>t.reduce(((s,i)=>{const n=e.indexOf(i);if(-1===n)throw new Error(`The provided ID (${t.join("")}) is invalid, as it contains characters that do not exist in the alphabet (${e.join("")})`);if("bigint"==typeof s)return s*BigInt(e.length)+BigInt(n);const r=s*e.length+n;if(Number.isSafeInteger(r))return r;if("function"==typeof BigInt)return BigInt(s)*BigInt(e.length)+BigInt(n);throw new Error("Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment")}),0),h=/^\+?\d+$/,o=t=>new RegExp(t.map((t=>a(t))).sort(((t,e)=>e.length-t.length)).join("|")),a=t=>t.replace(/[\s#$()*+,.?[\\\]^{|}-]/g,"\\$&");class l{constructor(t="",e=0,s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",i="cfhistuCFHISTU"){if(this.minLength=e,"number"!=typeof e)throw new TypeError(`Hashids: Provided 'minLength' has to be a number (is ${typeof e})`);if("string"!=typeof t)throw new TypeError(`Hashids: Provided 'salt' has to be a string (is ${typeof t})`);if("string"!=typeof s)throw new TypeError(`Hashids: Provided alphabet has to be a string (is ${typeof s})`);const r=Array.from(t),h=Array.from(s),l=Array.from(i);this.salt=r;const g=[...new Set(h)];var p;if(g.length<16)throw new Error(`Hashids: alphabet must contain at least 16 unique characters, provided: ${g.join("")}`);this.alphabet=(p=l,g.filter((t=>!p.includes(t))));const c=(d=g,l.filter((t=>d.includes(t))));var d;let f,u;this.seps=n(c,r),(0===this.seps.length||this.alphabet.length/this.seps.length>3.5)&&(f=Math.ceil(this.alphabet.length/3.5),f>this.seps.length&&(u=f-this.seps.length,this.seps.push(...this.alphabet.slice(0,u)),this.alphabet=this.alphabet.slice(u))),this.alphabet=n(this.alphabet,r);const b=Math.ceil(this.alphabet.length/12);this.alphabet.length<3?(this.guards=this.seps.slice(0,b),this.seps=this.seps.slice(b)):(this.guards=this.alphabet.slice(0,b),this.alphabet=this.alphabet.slice(b)),this.guardsRegExp=o(this.guards),this.sepsRegExp=o(this.seps),this.allowedCharsRegExp=(t=>new RegExp(`^[${t.map((t=>a(t))).sort(((t,e)=>e.length-t.length)).join("")}]+$`))([...this.alphabet,...this.guards,...this.seps])}encode(t,...e){let n=Array.isArray(t)?t:[...null!=t?[t]:[],...e];return 0===n.length?"":(n.every(s)||(n=n.map((t=>{return"bigint"==typeof t||"number"==typeof t?t:(e=String(t),h.test(e)?Number.parseInt(e,10):Number.NaN);var e}))),n.every(i)?this._encode(n).join(""):"")}decode(t){return t&&"string"==typeof t&&0!==t.length?this._decode(t):[]}encodeHex(t){let e=t;switch(typeof e){case"bigint":e=e.toString(16);break;case"string":if(!/^[\dA-Fa-f]+$/.test(e))return"";break;default:throw new Error(`Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof e})`)}const s=(i=e,12,n=t=>Number.parseInt(`1${t}`,16),Array.from({length:Math.ceil(i.length/12)},((t,e)=>n(i.slice(12*e,12*(e+1))))));var i,n;return this.encode(s)}decodeHex(t){return this.decode(t).map((t=>t.toString(16).slice(1))).join("")}isValidId(t){return this.allowedCharsRegExp.test(t)}_encode(t){let{alphabet:e}=this;const s=t.reduce(((t,e,s)=>t+("bigint"==typeof e?Number(e%BigInt(s+100)):e%(s+100))),0);let i=[e[s%e.length]];const r=[...i],{seps:h}=this,{guards:o}=this;if(t.forEach(((s,o)=>{const a=r.concat(this.salt,e);e=n(e,a);const l=((t,e)=>{const s=[];let i=t;if("bigint"==typeof i){const t=BigInt(e.length);do{s.unshift(e[Number(i%t)]),i/=t}while(i>BigInt(0))}else do{s.unshift(e[i%e.length]),i=Math.floor(i/e.length)}while(i>0);return s})(s,e);if(i.push(...l),o+1<t.length){const t=l[0].codePointAt(0)+o,e="bigint"==typeof s?Number(s%BigInt(t)):s%t;i.push(h[e%h.length])}})),i.length<this.minLength){const t=(s+i[0].codePointAt(0))%o.length;if(i.unshift(o[t]),i.length<this.minLength){const t=(s+i[2].codePointAt(0))%o.length;i.push(o[t])}}const a=Math.floor(e.length/2);for(;i.length<this.minLength;){e=n(e,e),i.unshift(...e.slice(a)),i.push(...e.slice(0,a));const t=i.length-this.minLength;if(t>0){const e=t/2;i=i.slice(e,e+this.minLength)}}return i}_decode(t){if(!this.isValidId(t))throw new Error(`The provided ID (${t}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join("")}${this.seps.join("")}${this.alphabet.join("")})`);const e=t.split(this.guardsRegExp),s=e[3===e.length||2===e.length?1:0];if(0===s.length)return[];const i=s[Symbol.iterator]().next().value,h=s.slice(i.length).split(this.sepsRegExp);let o=this.alphabet;const a=[];for(const t of h){const e=n(o,[i,...this.salt,...o].slice(0,o.length));a.push(r(Array.from(t),e)),o=e}return this._encode(a).join("")!==t?[]:a}}return e.default})()}));
//# sourceMappingURL=hashids.js.map